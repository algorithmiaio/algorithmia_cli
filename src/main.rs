#[macro_use]
extern crate serde_derive;

use crate::config::Profile;
use isatty::stderr_isatty;
use std::env;
use std::error::Error as StdError;
use std::io::Write;
use std::vec::IntoIter;
use termcolor::{Color, ColorChoice, StandardStream, WriteColor};

pub(crate) type DynError = Box<dyn std::error::Error + 'static + Send + Sync>;

pub(crate) const GRAY: Color = Color::Ansi256(8);
pub(crate) const BRIGHT_RED: Color = Color::Ansi256(9);
pub(crate) const PURPLE: Color = Color::Ansi256(93);

macro_rules! eprintln_red {
    ($fmt:expr) => ({
        use std::io::Write as _;
        use termcolor::WriteColor as _;
        let mut t_err = ::termcolor::StandardStream::stderr(crate::color_choice());
        let _ = t_err.set_color(::termcolor::ColorSpec::new().set_fg(Some(crate::BRIGHT_RED)));
        let _ = writeln!(t_err, $fmt);
        let _ = t_err.reset();
    });
    ($fmt:expr, $($arg:tt)*) => ({
        use std::io::Write as _;
        use termcolor::WriteColor as _;
        let mut t_err = ::termcolor::StandardStream::stderr(crate::color_choice());
        let _ = t_err.set_color(::termcolor::ColorSpec::new().set_fg(Some(crate::BRIGHT_RED)));
        let _ = writeln!(t_err, $fmt, $($arg)*);
        let _ = t_err.reset();
    });
}

macro_rules! quit_msg {
    ($fmt:expr) => ({
        eprintln!($fmt);
        ::std::process::exit(1)
    });
    ($fmt:expr, $($arg:tt)*) => ({
        eprintln!($fmt, $($arg)*);
        ::std::process::exit(1)
    });
}

fn print_cause_chain(e: &dyn StdError) {
    let mut err = e;
    while let Some(cause) = err.source() {
        eprintln!("  caused by: {}", cause);
        err = cause as &dyn StdError;
    }
}

macro_rules! quit_err {
    ($err:tt) => {{
        eprintln_red!("{}", $err);
        ::print_cause_chain(&$err);
        ::std::process::exit(1)
    }};
    ($fmt:expr, $err:tt) => {{
        eprintln_red!($fmt, $err);
        crate::print_cause_chain(&$err);
        ::std::process::exit(1)
    }};
    ($fmt:expr, $arg:expr, $err:tt) => {{
        eprintln_red!($fmt, $arg, $err);
        crate::print_cause_chain(&$err);
        ::std::process::exit(1)
    }};
}

mod algo;
mod auth;
pub mod config;
mod data;
mod version; // Module is generated by cargo build script

static ASCII_ART: &'static str = r##"
    /\
   /  \     Algorithmia
  /    \    Command Line Tools
 /\    /\
/  \  /  \
"##;

static USAGE: &'static str = r##"CLI for interacting with Algorithmia

Usage:
  algo [<cmd>] [options] [<args>...]
  algo [<cmd>] [--help | --version]

General commands include:
  auth      Configure authentication

Algorithm commands include:
  run       Runs an algorithm
  clone     Clones an algorithm source

Data commands include
  ls        List contents of a data directory
  mkdir     Create a data directory
  rmdir     Delete a data directory
  rm        Remove a file from a data directory
  cp        Copy file(s) to or from a data directory
  cat       Concatenate and print file(s) in a data directory

Global options:
  --help                Prints the help for a particular command
  --profile <name>      Run a particular command for the specified profile
"##;

// TODO: Add support for:
//
// Algorithm commands include:
// view      View algorithm details (e.g. cost)
// fork      Fork an algorithm
//
// Data commands include:
// download  Download file(s) from a collection
// rm        Delete file(s) in a collection
// chmod     Change permissions on a collection
//

fn print_usage() -> ! {
    println!("{}", USAGE);
    std::process::exit(0)
}

#[derive(RustcDecodable, Debug)]
struct MainArgs {
    arg_args: Vec<String>,
    arg_cmd: Option<String>,
    flag_h: bool,
}

pub(crate) fn color_choice() -> ColorChoice {
    if stderr_isatty() {
        ColorChoice::Auto
    } else {
        ColorChoice::Never
    }
}

fn main() {
    let mut args = env::args().peekable();
    let mut cmd_args: Vec<String> = Vec::new();
    let mut profile = "default".to_string();

    // Search for global options, push everything else onto cmd_args
    while let Some(arg) = args.next() {
        match &*arg {
            "--help" => {
                // grab one more arg in-case --help preceded <cmd>
                cmd_args.push(args.next().unwrap_or_default());
                print_cmd_usage(cmd_args.get(1).map(|s| s.as_str()));
            }
            "--profile" => profile = args.next().unwrap_or_else(|| profile.to_string()),
            "--version" => {
                let mut t_err = StandardStream::stderr(color_choice());
                let _ = t_err.set_color(::termcolor::ColorSpec::new().set_fg(Some(PURPLE)));
                let _ = writeln!(t_err, "{}", ASCII_ART);
                let _ = t_err.reset();
                println!("{}", version::VERSION);
                std::process::exit(0);
            }
            _ => cmd_args.push(arg),
        }
    }

    if cmd_args.len() < 2 {
        print_cmd_usage(None);
    } else {
        run(cmd_args, &profile);
    }
}

fn run(args: Vec<String>, profile_name: &str) {
    let cmd = match args.get(1) {
        Some(c) => c.clone(),
        _ => print_usage(),
    };

    let args_iter = args.into_iter();
    match &*cmd {
        "auth" => auth::Auth::new(profile_name).cmd_main(args_iter),
        _ => {
            let profile = Profile::lookup(profile_name);
            match &*cmd {
                "clone" => algo::GitClone::new(profile).cmd_main(args_iter),
                "ls" | "dir" => data::Ls::new(profile).cmd_main(args_iter),
                "mkdir" => data::MkDir::new(profile).cmd_main(args_iter),
                "rmdir" => data::RmDir::new(profile).cmd_main(args_iter),
                "rm" => data::Rm::new(profile).cmd_main(args_iter),
                "cp" | "copy" => data::Cp::new(profile).cmd_main(args_iter),
                "cat" => data::Cat::new(profile).cmd_main(args_iter),
                "run" => algo::Run::new(profile).cmd_main(args_iter),
                _ => print_usage(),
            }
        }
    };
}

fn print_cmd_usage(cmd: Option<&str>) -> ! {
    match cmd.unwrap_or_else(Default::default) {
        "auth" => auth::Auth::print_usage(),
        "ls" | "dir" => data::Ls::print_usage(),
        "mkdir" => data::MkDir::print_usage(),
        "rmdir" => data::RmDir::print_usage(),
        "rm" => data::Rm::print_usage(),
        "cp" | "copy" => data::Cp::print_usage(),
        "cat" => data::Cat::print_usage(),
        "clone" => algo::GitClone::print_usage(),
        "run" => algo::Run::print_usage(),
        _ => print_usage(),
    };
}

trait CmdRunner {
    fn cmd_main(&self, argv: IntoIter<String>);
    fn get_usage() -> &'static str;

    fn print_usage() -> ! {
        println!("{}", Self::get_usage());
        std::process::exit(0)
    }
}
